Flask Tutorials
----------------
https://www.tutorialspoint.com/flask/flask_environment.htm
https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
http://code.runnable.com/UhLMQLffO1YSAADK/handle-a-post-request-in-flask-for-python

To run a flask app
-------------------

$ python stressors.py
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger pin code: 363-681-609

To run pyferretWMS.py
----------------------
1) server mode:
$ ./pyferretWMS.py --server

2) with ferret command as an arg:
$ ./pyferretWMS_edit.py 'shade/x=-180:180/y=-90:90/lev=20v/pal=mpl_PSU_inferno/title=Maximum temp[k=@max]; shade/x=-180:180/y=-90:90/lev=(-inf)(0,140,5)(inf)/pal=mpl_Seq1_RdPu/title=Temperature&nbspvariance temp[k=@var]; shade/x=-180:180/y=-90:90/lev=(-inf)(30,40,0.5)(inf)/pal=mpl_PSU_viridis/title=Surface&nbspsalinity salt[k=1]'

gunicorn notes
--------------
Example of a very small WSGI app loaded with a custom Application:
http://docs.gunicorn.org/en/stable/custom.html

Customize flask response class:
https://blog.miguelgrinberg.com/post/customizing-the-flask-response-class

bottle + gunicorn:
http://blog.yprez.com/running-a-bottle-app-with-gunicorn.html

Ars:
----
- Gunicorn is a server that can run applications. 
- PyferretWMS is an app, and your Flask thing is also an app.
- Here http://docs.gunicorn.org/en/stable/custom.html is what they do in their script to run their app. 
So what you need is to somehow wrap the logic of their StandaloneApp into your Flask application, and that logic goes like: 

handler_app is given to StandaloneApp and there is this load() function that returns it. So your focus should be probably on figuring out what's going on in handler_app (or just copy it as your Flask app, then you can extend).

gunicorn custom app tested in PROJECTS/sandbox/gunicorn/custom.py. To run it:
$ python custom.py
-> Then go to http://127.0.0.1:8080 in browser
-> See on the screen: "Works fine" (the return of handler_app)

Cannot render multiple times to same template:
http://stackoverflow.com/questions/34009980/return-a-download-and-rendered-page-in-one-flask-response

Flask RESTful API
-----------------
http://blog.luisrei.com/articles/flaskrest.html


WSGI (http://lucumr.pocoo.org/2007/5/21/getting-started-with-wsgi/)
----
WSGI uses fn(environ, start_response) to render an html page taking as input a parameter specified in the url, eg:
http://localhost:8080/?subject=John

from cgi import parse_qs, escape

def hello_world(environ, start_response):
    parameters = parse_qs(environ.get('QUERY_STRING', ''))
    if 'subject' in parameters:
        subject = escape(parameters['subject'][0])
    else:
        subject = 'World'
    start_response('200 OK', [('Content-Type', 'text/html')])
    return ['''Hello %(subject)s
    Hello %(subject)s!

''' % {'subject': subject}]


flask start_response and environ
---------------------------------
http://stackoverflow.com/questions/9680073/how-do-i-use-flask-routes-with-apache-and-mod-wsgi

from flask import Flask

app = Flask(__name__)

@app.route('/')
def application(environ, start_response):
        status = '200 OK'
        output = "Hello World!"
        response_headers = [('Content-type', 'text/plain'),
                            ('Content-Length', str(len(output)))]
        start_response(status, response_headers)
        return [output]

@app.route('/upload')
def upload(environ, start_response):
        output = "Uploading"
        status = '200 OK'
        response_headers = [('Content-type', 'text/plain'),
                            ('Content-Length', str(len(output)))]
        start_response(status, response_headers)
        return [output]

if __name__ == '__main__':
        app.run()


STRUCTURE
---------
gunicorn passes the requests (GET request if coming from the URL, POST request if coming from a form) to the flask app through WSGI

refs:
-https://www.matthealy.com.au/blog/post/deploying-flask-to-amazon-web-services-ec2/

GUNICORN
-Flask application server (a python WSGI HTTP server)
-serves the python code (don't want to use the Flask development server, as it is not safe to do so for a production environment)

NGINX
-a web server installed on our instance that will forward requests from port 80 to our Flask app running internally. It is best practice to have a web server handle our port 80 requests, because the Flask application server (Gunicorn) we are using is designed to serve Python code, but not ideal for handling port 80 requests from the Internet.

SUPERVISOR
-An improvement that can made is to run Gunicorn via Supervisor. Supervisor looks after our Gunicorn processes and makes sure they are restarted if anything goes wrong, and ensures the processes are started at boot time.
(see: https://www.matthealy.com.au/blog/post/using-supervisor-with-flask-and-gunicorn/)


FLASK REQUESTS
---------------

flask.Request.args: gets the part in the URL after the question mark
(http://flask.pocoo.org/docs/0.10/api/#flask.Request.args)

Flask Context
--------------
http://flask.pocoo.org/docs/0.11/reqcontext/

If you look into how the Flask WSGI application internally works, you will find a piece of code that looks very much like this:

def wsgi_app(self, environ):
    with self.request_context(environ):
        try:
            response = self.full_dispatch_request()
        except Exception as e:
            response = self.make_response(self.handle_exception(e))
        return response(environ, start_response)

The method request_context() returns a new RequestContext object and uses it in combination with the with statement to bind the context. Everything that is called from the same thread from this point onwards until the end of the with statement will have access to the request globals (flask.request and others).

The request context internally works like a stack: The topmost level on the stack is the current active request. push() adds the context to the stack on the very top, pop() removes it from the stack again. On popping the application’s teardown_request() functions are also executed.

Another thing of note is that the request context will automatically also create an application context when it’s pushed and there is no application context for that application so far.