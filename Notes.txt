Flask Tutorials
----------------
https://www.tutorialspoint.com/flask/flask_environment.htm
https://blog.miguelgrinberg.com/post/the-flask-mega-tutorial-part-i-hello-world
http://code.runnable.com/UhLMQLffO1YSAADK/handle-a-post-request-in-flask-for-python

To run a flask app
-------------------

$ python stressors.py
 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)
 * Restarting with stat
 * Debugger is active!
 * Debugger pin code: 363-681-609

To run pyferretWMS.py
----------------------
1) server mode:
$ ./pyferretWMS.py --server

2) with ferret command as an arg:
$ ./pyferretWMS_edit.py 'shade/x=-180:180/y=-90:90/lev=20v/pal=mpl_PSU_inferno/title=Maximum temp[k=@max]; shade/x=-180:180/y=-90:90/lev=(-inf)(0,140,5)(inf)/pal=mpl_Seq1_RdPu/title=Temperature&nbspvariance temp[k=@var]; shade/x=-180:180/y=-90:90/lev=(-inf)(30,40,0.5)(inf)/pal=mpl_PSU_viridis/title=Surface&nbspsalinity salt[k=1]'

laptop
-------
[cnangini@lsce3174 ~]$ bash
[cnangini@lsce3174 ~]$ conda create -n myenv python=2
[cnangini@lsce3174 ~]$ source anaconda/bin/activate myenv
(myenv) [cnangini@lsce3174 ~]$ python
Python 2.7.12 |Continuum Analytics, Inc.| (default, Jul  2 2016, 17:42:40)
[GCC 4.4.7 20120313 (Red Hat 4.4.7-1)] on linux2
Type "help", "copyright", "credits" or "license" for more information.
Anaconda is brought to you by Continuum Analytics.
Please check out: http://continuum.io/thanks and https://anaconda.org
>>> import pyferret
>>> pyferret.start()
     NOAA/PMEL TMAP
     PyFERRET v7.021 (optimized)
     Linux 3.13.0-105-generic - 12/13/16
     13-Dec-16 23:29    

True
>>> quit()

Carsten has gunicorn (19.1.0) installed with conda and the import worked:

>> from gunicorn.app import base

Patrick's versions on webportals
---------------------------------
http://webportals.ipsl.jussieu.fr/ScientificApps/dev/forge_patrick/wms-pyferret/page_05.html

FORM PARAMS
-----------
levitus_climatology
temp[k=@max] OR salt[k=1]
shade/x=-180:180/y=-90:90/lev=20v/pal=mpl_PSU_inferno

/home/scratch01/mvhulten/analysis/mang-16B05-LD40_Bio_1y_ptrc_T_P80
dMn[z=0, l=1] OR dMn[z=0, l=2] (up to 10?)
shade/lev=20v/modulo/pal=light_centered
nav_lon, nav_lat

monthly_navy_winds
UWND[z=0, l=1]
shade/x=-180:180/y=-90:90/lev=20v/pal=mpl_PSU_inferno


FERRET DATASET DIR:
/homel/cnangini/.conda/envs/FERRET/share/fer_dsets

gunicorn notes
--------------
Example of a very small WSGI app loaded with a custom Application:
http://docs.gunicorn.org/en/stable/custom.html

Customize flask response class:
https://blog.miguelgrinberg.com/post/customizing-the-flask-response-class

bottle + gunicorn:
http://blog.yprez.com/running-a-bottle-app-with-gunicorn.html

Ferret datasets + commands examples
------------------------------------
etopo20 dset in FER_DIR:
~~~~~~~~~~~~~~~~~~~~~~~~
yes? use etopo20
yes? rose
yes? shade/x=-180:180/y=-90:90/lev=20v/pal=light_centered
OR   shade/x=-180:180/y=-90:90/lev=20v/levels=(-inf)(-5000,5000,500)(inf)/pal=light_centered
OR   shade/x=-180:180/y=-90:90/lev=20v/levels=(-8000,8000,500)
OR   shade/x=-180:180/y=-90:90/lev=20v/levels=(-8000,8000,500) dMn, nav_lon,nav_lat


Marco's manganese dset:
~~~~~~~~~~~~~~~~~~~~~~~
yes? use Mn...
yes? set window/aspect=.7
yes? shade dMn[z=0, l=10, d=DSET]
OR VARIABLE POC, PO4, ..., dMn, ...
yes? shade/lev=20v/pal=light_centered
OR   shade/modulo/lev=20v/pal=light_centered  #use modulo to remove weird end artifact
                          pal=light_gray
                          pal=rainbow

Quick hack to remove the land:
VARIABLE= dMn[z=0, l=1]*dMn[z=0, l=1]/dMn[z=0, l=1]

Ars:
----
- Gunicorn is a server that can run applications. 
- PyferretWMS is an app, and your Flask thing is also an app.
- Here http://docs.gunicorn.org/en/stable/custom.html is what they do in their script to run their app. 
So what you need is to somehow wrap the logic of their StandaloneApp into your Flask application, and that logic goes like: 

handler_app is given to StandaloneApp and there is this load() function that returns it. So your focus should be probably on figuring out what's going on in handler_app (or just copy it as your Flask app, then you can extend).

gunicorn custom app tested in PROJECTS/sandbox/gunicorn/custom.py. To run it:
$ python custom.py
-> Then go to http://127.0.0.1:8080 in browser
-> See on the screen: "Works fine" (the return of handler_app)

Cannot render multiple times to same template:
http://stackoverflow.com/questions/34009980/return-a-download-and-rendered-page-in-one-flask-response

Flask RESTful API
-----------------
http://blog.luisrei.com/articles/flaskrest.html


WSGI (http://lucumr.pocoo.org/2007/5/21/getting-started-with-wsgi/)
----
WSGI uses fn(environ, start_response) to render an html page taking as input a parameter specified in the url, eg:
http://localhost:8080/?subject=John

from cgi import parse_qs, escape

def hello_world(environ, start_response):
    parameters = parse_qs(environ.get('QUERY_STRING', ''))
    if 'subject' in parameters:
        subject = escape(parameters['subject'][0])
    else:
        subject = 'World'
    start_response('200 OK', [('Content-Type', 'text/html')])
    return ['''Hello %(subject)s
    Hello %(subject)s!

''' % {'subject': subject}]


flask start_response and environ
---------------------------------
http://stackoverflow.com/questions/9680073/how-do-i-use-flask-routes-with-apache-and-mod-wsgi

from flask import Flask

app = Flask(__name__)

@app.route('/')
def application(environ, start_response):
        status = '200 OK'
        output = "Hello World!"
        response_headers = [('Content-type', 'text/plain'),
                            ('Content-Length', str(len(output)))]
        start_response(status, response_headers)
        return [output]

@app.route('/upload')
def upload(environ, start_response):
        output = "Uploading"
        status = '200 OK'
        response_headers = [('Content-type', 'text/plain'),
                            ('Content-Length', str(len(output)))]
        start_response(status, response_headers)
        return [output]

if __name__ == '__main__':
        app.run()


STRUCTURE
---------
gunicorn passes the requests (GET request if coming from the URL, POST request if coming from a form) to the flask app through WSGI

refs:
-https://www.matthealy.com.au/blog/post/deploying-flask-to-amazon-web-services-ec2/

GUNICORN
-Flask application server (a python WSGI HTTP server)
-serves the python code (don't want to use the Flask development server, as it is not safe to do so for a production environment)

NGINX
-a web server installed on our instance that will forward requests from port 80 to our Flask app running internally. It is best practice to have a web server handle our port 80 requests, because the Flask application server (Gunicorn) we are using is designed to serve Python code, but not ideal for handling port 80 requests from the Internet.

SUPERVISOR
-An improvement that can made is to run Gunicorn via Supervisor. Supervisor looks after our Gunicorn processes and makes sure they are restarted if anything goes wrong, and ensures the processes are started at boot time.
(see: https://www.matthealy.com.au/blog/post/using-supervisor-with-flask-and-gunicorn/)


FLASK REQUESTS
---------------

flask.Request.args: gets the part in the URL after the question mark
(http://flask.pocoo.org/docs/0.10/api/#flask.Request.args)

Flask Context
--------------
http://flask.pocoo.org/docs/0.11/reqcontext/

If you look into how the Flask WSGI application internally works, you will find a piece of code that looks very much like this:

def wsgi_app(self, environ):
    with self.request_context(environ):
        try:
            response = self.full_dispatch_request()
        except Exception as e:
            response = self.make_response(self.handle_exception(e))
        return response(environ, start_response)

The method request_context() returns a new RequestContext object and uses it in combination with the with statement to bind the context. Everything that is called from the same thread from this point onwards until the end of the with statement will have access to the request globals (flask.request and others).

The request context internally works like a stack: The topmost level on the stack is the current active request. push() adds the context to the stack on the very top, pop() removes it from the stack again. On popping the application’s teardown_request() functions are also executed.

Another thing of note is that the request context will automatically also create an application context when it’s pushed and there is no application context for that application so far.

SESSIONS
---------
http://connor-johnson.com/2016/01/22/using-sessions-in-flask/

for secret key see:
https://gist.github.com/rduplain/2173954

sessions as counter objects:
http://code.runnable.com/Uhf58hcCo9RSAACs/using-sessions-in-flask-for-python

session cart:
http://stackoverflow.com/questions/33775017/flask-python-where-should-i-put-goods-that-go-to-cart-in-online-shop
http://stackoverflow.com/questions/32594269/how-to-append-existing-keys-by-value-in-python-dictionary
http://stackoverflow.com/questions/32713380/how-to-change-values-in-flask-session-dictionary-using-forms

passing session vars between routes:
http://stackoverflow.com/questions/27611216/how-to-pass-a-variable-between-flask-pages


from Miika:
~~~~~~~~~~~~~~

I think it helps to separate two concepts: model and persistence.

Model is something around a domain object, e.g. user, map, subscription, ... that incorporates logic related to that object. Often also persisting it to database and fetching from database to be available in the controller. In frameworks like Flask it is often used almost synonymously with ORM like SQLAlchemy or ActiveRecord in Rails.

ORM, Object relational mapper is something that converts between SQL and you programming language's objects. And these ORM related files are often a preferred place to put your "model" logic.

HTTP is a stateless protocol by design, each request/response pair knows nothing about what happened before automatically. Not even that it comes from the same user. There are basically two ways to persist data between requests (knowing who the user is, what maps are selected, etc.).

- Cookies, which basically is a string in the headers that both server and client can change and is always passed back and forth between client and server on every request. This is how the backend knows that request comes from the same user.
- Database of some sort. In frameworks like Flask, database is often accessed via ORM layer like SQLAlchemy, so in this sense, via model. Nothing really prevents you to write raw sql in simple cases to persist data about chosen maps between requests for example and bypass any model logic, but it is probably more consistent to just use a very thin model for this as well.

There frameworks often have a concept of session too. http://flask.pocoo.org/docs/0.11/api/#flask.session Which is a place to persist data during one user session. Now session can be backed by different kind of stores. You can have all the session data go back and forth in cookie (not a good idea if there is a lot of data), or you can just pass a session identifier in the cookie, have a session data in the database and then fetch it on each request from there. Flask defaults to have session information stored in the cookie.

So back to your specific question, should you use session or model to store the chosen maps? If it is enough that the information is kept as long as the user is logged in (or if there is no login, roughly as long as the browser is open or the backend does not restart), then the session is probably a good place to store it. If you want to have the selection be there when the user comes back tomorrow, then write a small model on top of SQLAlchemy (or use any other way to store it to database).

Do not use global variables. In these frameworks, controller object is created anew for each request. If you tried to store something there, it will be wiped out at the end of the response. There might be a way to store it somewhere really globally, but the there is a danger of mixing up different user's data etc. and you are up for a big mess (or at least implementing a lot of logic from scratch, which is already there in the session implementation).

Take a look at this or some other cookie tutorial https://www.nczonline.net/blog/2009/05/05/http-cookies-explained/

~~~~~~~~~~~~~~

Save map to file
-----------------

Try with gksm2ps

$ ssh asterix
cnangini@asterix1:~> module load ferret
cnangini@asterix1:~> cd $FER_DIR
cnangini@asterix1:/usr/local/install/ferret-6.9.6> cd bin/
cnangini@asterix1:/usr/local/install/ferret-6.9.6/bin> ls
build_fonts/  ferret@            Fgo*       Fpalette*     Fprint_template.csh*  gksm2ps*
Fdata*        ferret_paths       Fgo.csh*   Fpalette.csh*     Fpurge*       install_ferret_links*
Fdata.csh*    ferret_paths_bash      Fgrid@     Fpatch.csh*   Fpurge.csh*       install_ferret_links.csh*
Fdesc@        ferret_paths_ksh       Fgrids*    Fpattern*     FshowGO*      mtp*
Fdescr*       ferret_paths_template.csh  Fgrids.csh*    Fpattern.csh*     Fsort*        my_ferret_paths_template.csh
Fdescr.csh*   ferret_paths_template.sh   Finstall*  Fprint@       Fsort.csh*        my_ferret_paths_template.sh
Fenv*         ferret_v6.96*      Finstall.csh*  Fprint_template*  Fsort.nawk
cnangini@asterix1:/usr/local/install/ferret-6.9.6/bin> ls gksm2ps

Marco's script
--------------
/home/users/mvhulten/bin/meta2pdf

yes? set mode meta
yes? shade/x=-180:180/y=-90:90/lev=20v/pal=mpl_PSU_inferno #ferret command
yes? cancel mode meta

This outputs a metafile_*.plt file.
Marco's script uses gksm2ps to convert *.plt to *vec.pdf, *.eps, etc.

Timeseries
----------
Test with monthly_navy_winds.cdf. Try to plot time series avg over x and y coords in current map view box.

http://ferret.pmel.noaa.gov/Ferret/documentation/pyferret/pyferret-python-objects/

use monthly_navy_winds.cdf
plot uwnd[x=20:160@ave,y=0:45@ave]
list uwnd[x=20:160@ave,y=0:45@ave]

Image save
-----------

save csv file: http://code.runnable.com/UiIdhKohv5JQAAB6/how-to-download-a-file-generated-on-the-fly-in-flask-for-python
save png: http://stackoverflow.com/questions/7877282/how-to-send-image-generated-by-pil-to-browser

using jquery: http://codepen.io/anon/pen/RWraBJ plus:
- http://gis.stackexchange.com/questions/82950/add-simple-image-layers-to-mapbox-leaflet
- http://gis.stackexchange.com/questions/82950/add-simple-image-layers-to-mapbox-leaflet
- http://stackoverflow.com/questions/20790045/how-to-precisely-place-a-div-element-on-a-map-using-leaflet-js (this is to place rectangles; replace "L.rectangle(zones[0].area).addTo(thismap)" with "L.imageOverlay(imageUrl, imageBounds).addTo(thismap);")
- http://gis.stackexchange.com/questions/186131/placing-controls-outside-map-container-with-leaflet

From Patrick, save capture d'ecran:

L'outil qui sert à récupérer une image ou un pdf d'un site.

http://wkhtmltopdf.org/

En js: https://www.npmjs.com/package/wkhtmltoimage
En python: https://pypi.python.org/pypi/wkhtmltopdf/0.2

C'est ce qu'utilise WDD dans leur application Emissions du GCA

Redirect back
-------------
http://flask.pocoo.org/snippets/62/

Bokeh + flask
--------------
http://blog.thedataincubator.com/2015/09/painlessly-deploying-data-apps-with-bokeh-flask-and-heroku/
http://cfss.uchicago.edu/slides/week10_flaskPlotting.pdf

bokeh plot with dates:
http://stackoverflow.com/questions/33869292/how-can-i-set-the-x-axis-as-datetimes-on-a-bokeh-plot

directories
-----------
print("current wdir: ", os.getcwd())
tmpdir = tempfile.mkdtemp()
print('Temporary directory to remove: ', tmpdir)
os.chdir(tmpdir)
print("current wdir after cd: ", os.getcwd())